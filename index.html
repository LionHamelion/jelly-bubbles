<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <title>Amorphous Jelly Balls with Gravity and Smooth Cubic-Bezier Inflation</title>
  <style>
    /* Fullscreen canvas styling */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #222;
      height: 100%;
    }
    canvas {
      display: block;
      background: #333;
    }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
// -----------------------------------------------------------------------------
// 1. Utility functions
// -----------------------------------------------------------------------------

// Returns random number between [min, max).
function rand(min, max) {
  return Math.random() * (max - min) + min;
}

// A standard 2D cubic-bezier in [0..1], from (0,0) to (1,1) with control points
// (x1, y1) and (x2, y2). For a parameter t in [0..1], it returns the y component.
//
// We param by t, so the curve is B(t) = (x(t), y(t)):
//   x(t) = 3(1-t)^2 * t * x1 + 3(1-t)*t^2 * x2 + t^3
//   y(t) = 3(1-t)^2 * t * y1 + 3(1-t)*t^2 * y2 + t^3
// We ignore x(t), assuming t is already “the time” in [0..1], and just compute y(t).
function cubicBezierY(t, x1, y1, x2, y2) {
  // We just want the “y(t)” from a standard 1D cubic-bezier approach:
  // B(t).y = (1−3p2+3p4)t^3 + ...
  // Але простіше обчислити напряму через формулу нижче:

  const cX = 1 - 3*x2 + 3*x1;
  const bX = 3*x2 - 6*x1;
  const aX = 3*x1;

  const cY = 1 - 3*y2 + 3*y1;
  const bY = 3*y2 - 6*y1;
  const aY = 3*y1;

  // x(t) = aX t^3 + bX t^2 + cX t
  // y(t) = aY t^3 + bY t^2 + cY t
  // Але частіше роблять параметр “прямо y(t) = …”
  // Однак це підходить, якщо  t є “x(t)”, тобто якщо X = t. 
  // Для точного відтворення зазвичай потрібно вирішувати x(t)= T => t. 
  // Але припустімо, що “t” — це час [0..1], і ми безпосередньо обчислюємо y(t).
  // Сформулюємо напряму:
  
  // y(t) = 3(1−t)^2 t * y1 + 3(1−t) t^2 * y2 + t^3
  // (бо (0,0)->(x1,y1)->(x2,y2)->(1,1))
  // Виконаємо саме цю формулу.
  const oneMinusT = (1 - t);
  // y(t):
  const y = 3 * oneMinusT * oneMinusT * t * y1
          + 3 * oneMinusT * t * t * y2
          + t * t * t; // +0? Actually (1,1) => t^3 => “.y=1 * t^3”
  return y;
}

function cubicBezierCustom(t) {
  // p1=(0.55, -0.26), p2=(0.6,1.61)
  return cubicBezierY(t, .55,-0.26,.6,1.61);
}

// Compute the effective radius of a jelly ball along a given angle (for collision).
function getEffectiveRadius(ball, angle) {
  let bestIndex = 0;
  let bestDiff = Infinity;
  for (let i = 0; i < ball.numPoints; i++) {
    let diff = Math.abs(ball.points[i].angle - angle);
    diff = Math.min(diff, Math.PI * 2 - diff);
    if (diff < bestDiff) {
      bestDiff = diff;
      bestIndex = i;
    }
  }
  return ball.radius + ball.points[bestIndex].d;
}

// -----------------------------------------------------------------------------
// 2. JellyBall class
// -----------------------------------------------------------------------------

class JellyBall {
  constructor(x, y, targetRadius, numPoints = 40) {
    this.x = x;
    this.y = y;
    // Start from radius=1 and inflate to targetRadius with the cubic-bezier
    this.radius = 1;           // start
    this.targetRadius = targetRadius; // end
    this.inflationTime = 20.0;  // total time (seconds) to fully inflate
    this.age = 0;              // how long we've been alive (for inflation calc)

    // Center velocities
    this.vx = rand(-2, 2);
    this.vy = rand(-2, 2);

    // mass ~ area => updated each frame as radius changes
    this.mass = 1; 
    this.color = `hsl(${Math.floor(rand(0, 360))}, 70%, 50%)`;
    this.numPoints = numPoints;

    // Each contour point
    this.points = [];
    for (let i = 0; i < numPoints; i++) {
      let angle = i * (Math.PI * 2 / numPoints);
      this.points.push({ angle: angle, d: 0, dv: 0 });
    }
    // Spring physics
    this.kRest = 0.03;    
    this.kNeighbor = 1.1; 
    this.damping = 0.75;  
  }

  update(dt) {
    // 1) Update age, compute fraction in [0..1]
    this.age += dt;
    let t = this.age / this.inflationTime;
    if (t > 1) t = 1; 

    // 2) Apply cubic-bezier to get eased radius factor in [0..1]
    let eased = cubicBezierCustom(t);
    // Map eased => actual radius
    this.radius = 1 + (this.targetRadius - 1) * eased;
    // Recalc mass ~ radius^2
    this.mass = this.radius * this.radius;

    // 3) Spring update for contour
    for (let i = 0; i < this.numPoints; i++) {
      let p = this.points[i];
      let pPrev = this.points[(i - 1 + this.numPoints) % this.numPoints];
      let pNext = this.points[(i + 1) % this.numPoints];
      let force = -this.kRest * p.d;
      force += this.kNeighbor * (pPrev.d + pNext.d - 2 * p.d);
      p.dv += force * dt;
      p.dv *= this.damping;
      p.d += p.dv * dt;
      // clamp
      p.d = Math.max(Math.min(p.d, this.radius * 0.5), -this.radius * 0.5);
    }
  }

  applyForceAt(impactAngle, force) {
    impactAngle = (impactAngle % (Math.PI * 2) + Math.PI * 2) % (Math.PI * 2);
    let bestIndex = 0;
    let bestDiff = Infinity;
    for (let i = 0; i < this.numPoints; i++) {
      let diff = Math.abs(this.points[i].angle - impactAngle);
      diff = Math.min(diff, Math.PI * 2 - diff);
      if (diff < bestDiff) {
        bestDiff = diff;
        bestIndex = i;
      }
    }
    this.points[bestIndex].dv += force / this.radius;
    // Distribute portion
    let neighborForce = (force * 0.5) / this.radius;
    let idxPrev = (bestIndex - 1 + this.numPoints) % this.numPoints;
    let idxNext = (bestIndex + 1) % this.numPoints;
    this.points[idxPrev].dv += neighborForce;
    this.points[idxNext].dv += neighborForce;
  }

  draw(ctx) {
    ctx.beginPath();
    for (let i = 0; i < this.numPoints; i++) {
      let p = this.points[i];
      let r = this.radius + p.d;
      let px = this.x + r * Math.cos(p.angle);
      let py = this.y + r * Math.sin(p.angle);
      if (i === 0) {
        ctx.moveTo(px, py);
      } else {
        ctx.lineTo(px, py);
      }
    }
    ctx.closePath();
    ctx.fillStyle = this.color;
    ctx.fill();
  }
}

// -----------------------------------------------------------------------------
// 3. PhysicsEngine
// -----------------------------------------------------------------------------

class PhysicsEngine {
  constructor(canvas, numBalls = 5) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.balls = [];

    // Spawn initial set
    for (let i = 0; i < numBalls; i++) {
      let r = rand(30, 60);
      let x = rand(r, canvas.width - r);
      let y = rand(r, canvas.height - r);
      this.balls.push(new JellyBall(x, y, r, 40));
    }

    this.lastTime = 0;

    // Basic physics params
    this.centerDamping = 0.994;
    this.collisionDeformationFactor = 0.02;
    this.mouseImpulseFactor = 0.2;

    // Gravity
    this.G = 0.4;
    this.maxGravForce = 50;

    // Mouse / dragging
    this.mouseX = 0;
    this.mouseY = 0;
    this.draggedBall = null;
    this.dragStart = { x: 0, y: 0 };
    this.dragCurrent = { x: 0, y: 0 };

    this.resize();
    window.addEventListener('resize', () => this.resize());
    this.initMouseEvents();
    this.initKeyEvents();

    requestAnimationFrame((timestamp) => this.loop(timestamp));
  }

  resize() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
  }

  initMouseEvents() {
    this.canvas.addEventListener('mousemove', (e) => {
      const rect = this.canvas.getBoundingClientRect();
      this.mouseX = e.clientX - rect.left;
      this.mouseY = e.clientY - rect.top;

      if (this.draggedBall) {
        this.dragCurrent.x = this.mouseX;
        this.dragCurrent.y = this.mouseY;
      }
    });

    this.canvas.addEventListener('mousedown', (e) => {
      const rect = this.canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      for (let ball of this.balls) {
        let dx = mx - ball.x;
        let dy = my - ball.y;
        if (dx * dx + dy * dy <= ball.radius * ball.radius) {
          this.draggedBall = ball;
          this.dragStart = { x: mx, y: my };
          this.dragCurrent = { x: mx, y: my };
          break;
        }
      }
    });

    this.canvas.addEventListener('mouseup', () => {
      if (this.draggedBall) {
        const dx = this.dragCurrent.x - this.dragStart.x;
        const dy = this.dragCurrent.y - this.dragStart.y;
        this.draggedBall.vx += dx * this.mouseImpulseFactor;
        this.draggedBall.vy += dy * this.mouseImpulseFactor;
        // Deformation
        const angle = Math.atan2(dy, dx);
        this.draggedBall.applyForceAt(angle, dx * this.mouseImpulseFactor * 10);
        this.draggedBall = null;
      }
    });
  }

  // Spawns a new ball at cursor, inflating with cubic-bezier
  initKeyEvents() {
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        this.spawnNewBallAtCursor();
      }
    });
  }
  spawnNewBallAtCursor() {
    let r = rand(60, 70);
    let newBall = new JellyBall(this.mouseX, this.mouseY, r, 40);
    // random velocity
    newBall.vx = rand(-1, 1);
    newBall.vy = rand(-1, 1);
    this.balls.push(newBall);
  }

  loop(timestamp) {
    const dt = (timestamp - this.lastTime) * 0.06 || 1;
    this.lastTime = timestamp;
    this.update(dt);
    this.render();
    requestAnimationFrame((ts) => this.loop(ts));
  }

  update(dt) {
    // 1) Update + move
    for (let ball of this.balls) {
      ball.update(dt);
      ball.x += ball.vx * dt;
      ball.y += ball.vy * dt;
    }

    // 2) Gravity between pairs
    for (let i = 0; i < this.balls.length; i++) {
      for (let j = i + 1; j < this.balls.length; j++) {
        let A = this.balls[i];
        let B = this.balls[j];
        let dx = B.x - A.x;
        let dy = B.y - A.y;
        let dist = Math.hypot(dx, dy);
        if (dist === 0) continue;

        let force = this.G * (A.mass * B.mass) / (dist * dist);
        if (force > this.maxGravForce) {
          force = this.maxGravForce;
        }
        let nx = dx / dist;
        let ny = dy / dist;
        A.vx += (force / A.mass) * nx * dt;
        A.vy += (force / A.mass) * ny * dt;
        B.vx -= (force / B.mass) * nx * dt;
        B.vy -= (force / B.mass) * ny * dt;
      }
    }

    // 3) Collide with walls
    for (let ball of this.balls) {
      if (ball.x + ball.radius > this.canvas.width) {
        ball.x = this.canvas.width - ball.radius;
        ball.vx *= -1;
      } else if (ball.x - ball.radius < 0) {
        ball.x = ball.radius;
        ball.vx *= -1;
      }
      if (ball.y + ball.radius > this.canvas.height) {
        ball.y = this.canvas.height - ball.radius;
        ball.vy *= -1;
      } else if (ball.y - ball.radius < 0) {
        ball.y = ball.radius;
        ball.vy *= -1;
      }
    }

    // 4) Collisions between balls
    for (let i = 0; i < this.balls.length; i++) {
      for (let j = i+1; j < this.balls.length; j++) {
        let A = this.balls[i];
        let B = this.balls[j];
        let dx = B.x - A.x;
        let dy = B.y - A.y;
        let dist = Math.hypot(dx, dy);
        if (dist === 0) continue;
        let nx = dx / dist;
        let ny = dy / dist;
        let angle = Math.atan2(dy, dx);

        let effA = getEffectiveRadius(A, angle);
        let effB = getEffectiveRadius(B, angle + Math.PI);
        let minDist = effA + effB;
        if (dist < minDist) {
          let overlap = (minDist - dist)/2;
          A.x -= overlap*nx;
          A.y -= overlap*ny;
          B.x += overlap*nx;
          B.y += overlap*ny;

          let relVel = (B.vx - A.vx)*nx + (B.vy - A.vy)*ny;
          if (relVel < 0) {
            let restitution = 0.1;
            let impulseMag = -(1 + restitution)*relVel / (1/A.mass + 1/B.mass);
            const velocityScale = 0.2;
            A.vx -= velocityScale*(impulseMag/A.mass)*nx;
            A.vy -= velocityScale*(impulseMag/A.mass)*ny;
            B.vx += velocityScale*(impulseMag/B.mass)*nx;
            B.vy += velocityScale*(impulseMag/B.mass)*ny;

            // Deform
            A.applyForceAt(angle, -impulseMag*this.collisionDeformationFactor);
            B.applyForceAt(angle+Math.PI, -impulseMag*this.collisionDeformationFactor);
          }
        }
      }
    }

    // 5) Damping
    for (let ball of this.balls) {
      ball.vx *= this.centerDamping;
      ball.vy *= this.centerDamping;
    }
  }

  render() {
    this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
    for (let ball of this.balls) {
      ball.draw(this.ctx);
    }
    // drag line
    if (this.draggedBall) {
      this.ctx.beginPath();
      this.ctx.moveTo(this.draggedBall.x, this.draggedBall.y);
      this.ctx.lineTo(this.dragCurrent.x, this.dragCurrent.y);
      this.ctx.strokeStyle = 'white';
      this.ctx.lineWidth = 2;
      this.ctx.stroke();
    }
  }
}

// Init
document.addEventListener('DOMContentLoaded', () => {
  const canvas = document.getElementById('canvas');
  new PhysicsEngine(canvas, 0);
});
</script>
</body>
</html>
